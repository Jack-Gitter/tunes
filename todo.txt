tunes todos:

today!!!
remove all read-update-execute data races -- either make them transactions, or put explicit constraints on the database

data integrity:
    protobuf?
    
testing:
    implement tests
    implement a git workflow to run tests on push

general: 
    swagger?
    rework file structure?

errors:
    the errors are a mess, think about them and fix! -- add a custom error type, we'll probably be able to get rid of "found" everywhere -- if we want
    make an error that has an error type, then make a function to handle error types and pass in a gin context. if the error is of specific type, do c.json(specificstatuscode)
    check the error type responded by neo4j, then error or do something accordingly. We need to 

endpoints: 
    general: 
        clean up endpoint names

        FOR LOGGING IN AND CREATING POST -- JUST LET THE SQL TO THE WORK, MAKE CONSTRAINTS!!! -- remove read-write-update antipattern

        make the createPost endpoint either into a transaction OR just add a constraint on the database so that PK and trackID have to be unique -- second is good, do this in migration script!
        make logging in a transaction -- the whole user creation part of it maybe

    user
    posts
        like another post
        unlike a post
    comments
        create
        read (paginated)
        update
        delete
        
caching:
    redis 
        read up on caching techniques!!! 

dockerize:
    neo4j
    redis

admin: 
    cors


caching questions: 
    i validate cadhe on every data change — what about data race with get and data change where data change clears cache but get reaches db first and caches data?
    also updating cache after db writes — we have one post then another which changes a value. A hits db first then b, but b writes to cache first then a. how to prevent?
